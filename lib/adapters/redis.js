'use strict';

const HashBase = require('./hash-base');
const is = require('./../is.js');
const setting = require('./../settings.js');
const Redis = require('redis');
const log = require('./../log.js');

const code = {
	broken: 'CONNECTION_BROKEN',
	timeout: 'ETIMEDOUT'
};

/**
 * @extends {HashBase}
 */
class RedisHash extends HashBase {
	/**
	 * @param {Function} [readyHandler] Handle connection failure
	 */
	constructor(readyHandler) {
		super();

		/** @type {RedisClient} */
		this.client = Redis.createClient(setting.redis.port, setting.redis.hostname, {
			max_attempts: 2
		});

		this.client.on('error', err => {
			if (err.code == code.broken) {
				// if unable to connect to Redis then use in-memory hash only
				this.available = false;
				if (is.callable(readyHandler)) { readyHandler(this.available); }
				log.error("Unable to connect to Redis");
			} else {
				log.error("Error during redis call: %s", err.toString());
			}
		});
		this.client.on('connect', () => {
			// Redis queues commands while a connection is pending. Once the connection completes,
			// we can assume pending inserts are completed.
			this.pendingInserts = [];
			this.authorize();
		});
		
		this.authorize();
	}

	select(key, callback) {
		this.client.get(key, callback);
	}

	selectMember(key, memberKey, callback) {
		this.client.hget(key, memberKey, callback);
	}

	selectAll(key, callback) {
		this.client.hgetall(key, callback);
	}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} value
	 * @param {Function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	add(key, value, callback) {
		if (!this.client.connected) { this.pendingInserts.push({ add: arguments }); }
		this.client.set(key, value, callback);
	}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {String} value
	 * @param {Function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	addMember(key, memberKey, value, callback) {
		if (!this.client.connected) { this.pendingInserts.push({ addMember: arguments }); }
		this.client.hset(key, memberKey, value, callback);
	}

	addAll(key, hash, callback) {
		if (!this.client.connected) { this.pendingInserts.push({ addAll: arguments }); }
		this.client.hmset(key, hash, callback);
	}

	exists(key, callback) {
		this.client.exists(key, callback);
	}

	memberExists(key, memberKey, callback) {
		this.client.hexists(key, memberKey, callback);
	}

	keys(key, callback) {
		this.client.keys(key, callback)
	}

	memberKeys(key, callback) {
		this.client.hkeys(key, callback);
	}

	/**
	 * @param {String|String[]} key One or more item keys
	 * @param {function} callback
	 */
	remove(key, callback) {
		if (is.array(key)) {
			this.client.hdel(key, callback);
		} else {
			this.client.del(key, callback);
		}
	}

	/**
	 * Node redis is a little dumb here and merely toString()'s the field
	 * array if passed as a second argument so instead combine the key
	 * and fields which get converted into a list of arguments which is
	 * what redis server hdel actuall expects
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {Function} callback
	 */
	removeMember(key, memberKey, callback) {
		this.client.hdel([key].concat(memberKey), callback);
	}

	responder(key, type, callback) {
		return (err, reply) => {
			let error = this.hasError(key, err);

			if (is.callable(callback)) {
				let response = null;
				if (type === undefined) { type = replyType.none; }

				if (error) {
					if (type !== replyType.raw && type !== replyType.json) { response = false; }
				} else {
					switch (type) {
						case replyType.bit: response = (reply == 1); break;
						case replyType.okay: response = (reply == 'OK'); break;
						case replyType.count: response = (reply == howMany(key)); break;
						case replyType.raw: response = reply; break;
						case replyType.json: response = (reply) ? JSON.parse(reply) : null; break;
					}
				}
				callback(response);
			}
		}
	}

	authorize() {
		this.client.auth(setting.redis.auth);
	}

	/**
	 * Delete one key and add another
	 * @param {String} key Hash key or old string key
	 * @param {String} p2 Old hash field or new string key
	 * @param {String|Object} p3 New hash field or value
	 * @param {String|Object|function(boolean)} p4 Hash value or callback
	 * @param {function(boolean)} [p5] Callback if replacing hash field
	 */
	replace(key, p2, p3, p4, p5) {
		if (p5 === undefined) {
			this.client.multi()
				.del(key)
				.set(p2, normalize(p3))
				.exec((err, replies) => {
					log.info('MULTI got %d replies', replies.length);
					replies.forEach((reply, index) => {
						console.log("Reply " + index + ": " + reply.toString());
					});
				});
		} else {
			// hash
			this.client.multi()
				.hdel(key, p2)
				.hset(key, p3, normalize(p4))
				.exec((err, replies) => {
					log.info('MULTI got %d replies', replies.length);
					replies.forEach((reply, index) => {
						console.log("Reply " + index + ": " + reply.toString());
					});
				});
		}
	};
}

module.exports = RedisHash;
