'use strict';

const HashBase = require('./hash-base');
const is = require('./../is.js');
const setting = require('./../settings.js');
const Redis = require('redis');
const log = require('./../log.js');

const code = {
	broken: 'CONNECTION_BROKEN',
	timeout: 'ETIMEDOUT'
};

/**
 * @extends {HashBase}
 */
class RedisHash extends HashBase {
	constructor() {
		super();

		/** @type {RedisClient} */
		this.client = Redis.createClient(setting.redis.port, setting.redis.hostname, {
			max_attempts: 2
		});

		this.client.on('error', err => {
			if (err.code == code.broken) {
				// if unable to connect to Redis then use in-memory hash only
				this.available = false;
				log.error("Unable to connect to Redis - failing over to in-memory hash");
			} else {
				log.error("Error during redis call: %s", err.toString());
			}
		});
		redis.on('connect', this.authorize);

		this.authorize();
	}

	select(key, callback) {
		this.client.get(key, callback);
	}

	selectMember(key, memberKey, callback) {
		this.client.hget(key, memberKey, callback);
	}

	selectAll(key, callback) {
		this.client.hgetall(key, callback);
	}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} value
	 * @param {Function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	add(key, value, callback) {
		this.client.set(key, value, callback);
	}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {String} value
	 * @param {Function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	addMember(key, memberKey, value, callback) {
		this.client.hset(key, memberKey, value, callback);
	}

	addAll(key, hash, callback) {
		this.client.hmset(key, hash, callback);
	}

	exists(key, callback) {
		this.client.exists(key, callback);
	}

	memberExists(key, memberKey, callback) {
		this.client.hexists(key, memberKey, callback);
	}

	keys(key, callback) {
		this.client.keys(key, callback)
	}

	memberKeys(key, callback) {
		this.client.hkeys(key, callback);
	}

	/**
	 * @param {String|String[]} key One or more item keys
	 * @param {function} callback
	 */
	remove(key, callback) {
		if (is.array(key)) {
			this.client.hdel(key, callback);
		} else {
			this.client.del(key, callback);
		}
	}

	responder(key, type, callback) {
		return (err, reply) => {
			let error = this.hasError(key, err);

			if (is.callable(callback)) {
				let response = null;
				if (type === undefined) { type = replyType.none; }

				if (error) {
					if (type !== replyType.raw && type !== replyType.json) { response = false; }
				} else {
					switch (type) {
						case replyType.bit: response = (reply == 1); break;
						case replyType.okay: response = (reply == 'OK'); break;
						case replyType.count: response = (reply == howMany(key)); break;
						case replyType.raw: response = reply; break;
						case replyType.json: response = (reply) ? JSON.parse(reply) : null; break;
					}
				}
				callback(response);
			}
		}
	}

	authorize() {
		this.client.auth(setting.redis.auth);
	}
}

module.exports = RedisHash;
