'use strict';

const is = require('../is.js');
const log = require('../log.js');
const events = require('events');

/**
 * @extends {EventEmitter}
 */
class CacheProvider extends events.EventEmitter {

	constructor() {
		super();
		this.eventType = eventType;
		this.replyType = replyType;
		/**
		 * Whether provier is ready to receive commands
		 * Redis and others can receive commands before they're connected
		 * @type {Boolean}
		 */
		this.ready = true;
		/**
		 * Whether the provider is connected
		 * @type {Boolean}
		 */
		this.connected = false;
	}
	select(key, callback) {}

	selectMember(key, memberKey, callback) {}

	selectAll(key, callback) {}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} value
	 * @param {Function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	add(key, value, callback) {}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {String} value
	 * @param {Function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	addMember(key, memberKey, value, callback) {}

	/**
	 * Insert hash
	 * @param {String} key
	 * @param {Object} hash
	 * @param {Function} callback
	 */
	addAll(key, hash, callback) {}

	exists(key, callback) {}

	memberExists(key, memberKey, callback) {}

	keys(key, callback) {}

	memberKeys(key, callback) {}

	/**
	 * @param {String|String[]} key One or more item keys
	 * @param {function} callback
	 */
	remove(key, callback) {}

	removeMember(key, memberKey, callback) {}

	/**
	 *
	 * @param {String} key
	 * @param {Function} callback
	 * @param {Number} type
	 * @returns {Function}
	 */
	responder(key, callback, type) {
		return (err, reply) => {
			let error = this.hasError(key, err);

			if (is.callable(callback)) {
				let response = null;
				if (type === undefined) { type = this.replyType.NONE; }

				if (error) {
					if (type !== this.replyType.raw && type !== this.replyType.JSON) { response = false; }
				} else {
					switch (type) {
						case this.replyType.BIT: response = this.isTrue(reply); break;
						case this.replyType.OKAY: response = this.isOkay(reply); break;
						case this.replyType.COUNT: response = (reply == howMany(key)); break;
						case this.replyType.RAW: response = reply; break;
						case this.replyType.JSON: response = this.parseObject(reply); break;
						case this.replyType.NONE: response = true; break;
					}
				}
				callback(response);
			}
		}
	}

	/**
	 * Deserialize object strings
	 * @param {Object|String} value
	 */
	parseObject(value) {
		return (is.empty(value)) ? null : JSON.parse(value);
	}

	/**
	 * @param {Number|Boolean} value
	 * @returns {Boolean}
	 */
	isTrue(value) { return value == 1; }

	/**
	 * @param {String|Boolean} value
	 * @returns {Boolean}
	 */
	isOkay(value) { return value == 'OK'; }

	/**
	 * Whether Redis returned an error
	 * @param {String|String[]} key
	 * @param {Object|Number|String} err
	 * @return {Boolean}
	 */
	hasError(key, err) {
		if (err !== null) {
			if (is.array(key)) { key = key.toString(); }
			log.error('Operation with key "%s" resulted in %s', key, err.toString());
			return true;
		}
		return false;
	}

	/**
	 * Normalize data value
	 * @param {Object|String|Array} value
	 */
	normalize(value) { return (typeof value == 'object') ? JSON.stringify(value) : value; }
}

// - Private static members ---------------------------------------------------

/**
 * @enum {String}
 */
const eventType = {
	CONNECTED: 'connected',
	BROKEN: 'broken'
};
/**
 * Expected hash response used for validation and parsing
 * @enum {Number}
 */
const replyType = {
	NONE: 0,            // don't check the reply
	OKAY: 1,            // check for 'OK'
	COUNT: 2,           // reply should match key count
	BIT: 3,             // 1 or 0
	RAW: 4,             // return raw data without validation or parsing
	JSON: 5             // parse as JSON
};

/**
 * How many datum referenced by key
 * @param {String|String[]} key
 * @returns {Number}
 */
function howMany(key) { return is.array(key) ? key.length : 1; }

module.exports = CacheProvider;