'use strict';

const CacheProvider = require('./cache-provider');
const is = require('../is.js');
const config = require('../config.js');
const Redis = require('redis');
const log = config.provider.log;

/**
 * @extends {EventEmitter}
 * @extends {CacheProvider}
 */
class RedisProvider extends CacheProvider {
	/**
	 * @param {String} url
	 */
	constructor(url) {
		super();

		this.host = config.fromUrl(url);

		/** @type {RedisClient} */
		this.client = Redis.createClient(this.host.port, this.host.url, {
			max_attempts: 2
		});

		this.client.on('error', err => {
			if (err.code == code.BROKEN) {
				// if unable to connect to Redis then use in-memory hash only
				log.error("Unable to connect to Redis at %s:%d", this.host.url, this.host.port);
				this.ready = false;
				this.emit(this.eventType.BROKEN);
			} else {
				log.error("Error during redis call: %s", err.toString());
			}
		});
		this.client.on('connect', () => {
			this.connected = true;
			this.authorize();
			this.emit(this.eventType.CONNECTED);
		});
		this.authorize();
	}

	select(key, callback) {
		this.client.get(key, callback);
	}

	selectMember(key, memberKey, callback) {
		this.client.hget(key, memberKey, callback);
	}

	selectAll(key, callback) {
		this.client.hgetall(key, callback);
	}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} value
	 * @param {Function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	add(key, value, callback) {
		this.client.set(key, value, callback);
	}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {String} value
	 * @param {Function(Object, (String|Number)} [callback] Method generated by responder()
	 * @see http://redis.io/commands/hset
	 */
	addMember(key, memberKey, value, callback) {
		this.client.hset(key, memberKey, value, callback);
	}

	addAll(key, hash, callback) {
		this.client.hmset(key, hash, callback);
	}

	exists(key, callback) {
		this.client.exists(key, callback);
	}

	memberExists(key, memberKey, callback) {
		this.client.hexists(key, memberKey, callback);
	}

	keys(key, callback) {
		this.client.keys(key, callback)
	}

	memberKeys(key, callback) {
		this.client.hkeys(key, callback);
	}

	/**
	 * @param {String|String[]} key One or more item keys
	 * @param {function} callback
	 */
	remove(key, callback) {
		if (is.array(key)) {
			this.client.hdel(key, callback);
		} else {
			this.client.del(key, callback);
		}
	}

	/**
	 * Node redis is a little dumb here and merely toString()'s the field
	 * array if passed as a second argument so instead combine the key
	 * and fields which get converted into a list of arguments which is
	 * what redis server hdel actuall expects
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {Function} callback
	 */
	removeMember(key, memberKey, callback) {
		this.client.hdel([key].concat(memberKey), callback);
	}

	authorize() {
		this.client.auth(this.host.password);
	}

	/**
	 * Delete one key and add another
	 * @param {String} key Hash key or old string key
	 * @param {String} p2 Old hash field or new string key
	 * @param {String|Object} p3 New hash field or value
	 * @param {String|Object|function(boolean)} p4 Hash value or callback
	 * @param {function(boolean)} [p5] Callback if replacing hash field
	 */
	replace(key, p2, p3, p4, p5) {
		if (p5 === undefined) {
			this.client.multi()
				.del(key)
				.set(p2, this.normalize(p3))
				.exec((err, replies) => {
					log.info('MULTI got %d replies', replies.length);
					replies.forEach((reply, index) => {
						log.info("Reply %d: %s", index, reply);
					});
				});
		} else {
			// hash
			this.client.multi()
				.hdel(key, p2)
				.hset(key, p3, this.normalize(p4))
				.exec((err, replies) => {
					log.info('MULTI got %d replies', replies.length);
					replies.forEach((reply, index) => {
						log.info("Reply %d: %s", index, reply);
					});
				});
		}
	};
}

module.exports = RedisProvider;

// - Private static members ---------------------------------------------------

const code = {
	BROKEN: 'CONNECTION_BROKEN',
	TIMEOUT: 'ETIMEDOUT'
};
