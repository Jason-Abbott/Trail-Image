'use strict';

const TI = require('../../');
const is = TI.is;
const db = TI.provider;
/** @type {CacheBase} */
const CacheBase = TI.Cache.Base;
/** @type {CacheItem} */
const CacheItem = TI.Cache.Item;
const Redis = require('redis');
const URL = require('url');

/**
 * @extends {EventEmitter}
 * @extends {CacheBase}
 */
class RedisCache extends CacheBase {
	/**
	 * @param {String} redisUrl
	 */
	constructor(redisUrl) {
		super();

		/** @type {Url} */
		let url = URL.parse(redisUrl);

		/** @type {RedisClient} */
		this.client = Redis.createClient(url.port, url.hostname, {
			max_attempts: 2
		});

		this.client.on('error', err => {
			let fatal = false;

			if (err.code == code.BROKEN) {
				// if unable to connect to Redis then use in-memory hash only
				db.log.error("Unable to connect to Redis at %s:%d", url.hostname, url.port);
				fatal = true;
			} else if (err.code == code.ERROR && err.command == 'AUTH') {
				db.log.error("Unable to authorize Redis at %s:%d (%s)", url.hostname, url.port, err.message);
				fatal = true;
			} else {
				// log error but keep trying to connect
				db.log.error("Error during redis call: %s", err.message);
			}

			if (fatal) {
				this.ready = false;
				this.emit(CacheBase.EventType.FATAL);
			}
		});
		this.client.on('connect', () => {
			db.log.infoIcon(TI.icon.link, "Redis connected to %s:%d", url.hostname, url.port);
			this.connected = true;
			this.authorize(url.auth);
			this.emit(CacheBase.EventType.CONNECTED);
		});
		this.authorize(url.auth);
	}

	select(key, callback) {
		this.client.get(key, callback);
	}

	selectMember(key, memberKey, callback) {
		this.client.hget(key, memberKey, callback);
	}

	selectAll(key, callback) {
		this.client.hgetall(key, callback);
	}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} value
	 * @param {function(Object,(String|Number)} [callback] Method generated by responder()
	 */
	add(key, value, callback) {
		this.client.set(key, value, callback);
	}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {String} value
	 * @param {function(Object,(String|Number)} [callback] Method generated by responder()
	 * @see http://redis.io/commands/hset
	 */
	addMember(key, memberKey, value, callback) {
		this.client.hset(key, memberKey, value, callback);
	}

	addAll(key, hash, callback) {
		this.client.hmset(key, hash, callback);
	}

	exists(key, callback) {
		this.client.exists(key, callback);
	}

	memberExists(key, memberKey, callback) {
		this.client.hexists(key, memberKey, callback);
	}

	/**
	 * Keys matching pattern
	 * @param {String} pattern
	 * @param callback
	 */
	keys(pattern, callback) {
		this.client.keys(pattern, callback)
	}

	memberKeys(key, callback) {
		this.client.hkeys(key, callback);
	}

	/**
	 * @param {String|String[]} key One or more item keys
	 * @param {function} callback
	 */
	remove(key, callback) {
		if (is.array(key)) {
			this.client.hdel(key, callback);
		} else {
			this.client.del(key, callback);
		}
	}

	/**
	 * Node redis is a little dumb here and merely toString()'s the field
	 * array if passed as a second argument so instead combine the key
	 * and fields which get converted into a list of arguments which is
	 * what redis server hdel actuall expects
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {Function} callback
	 */
	removeMember(key, memberKey, callback) {
		this.client.hdel([key].concat(memberKey), callback);
	}

	/**
	 * Current client wants password only for auth
	 * @param {String} auth <username>:<password>
	 */
	authorize(auth) {
		let parts = auth.split(':');
		db.log.infoIcon(TI.icon.login, "Authenticating Redis connection");
		this.client.auth(parts[1]);
	}

	/**
	 * Delete one key and add another
	 * @param {String} key Hash key or old string key
	 * @param {String} p2 Old hash field or new string key
	 * @param {String|Object} p3 New hash field or value
	 * @param {String|Object|function(boolean)} p4 Hash value or callback
	 * @param {function(boolean)} [p5] Callback if replacing hash field
	 */
	replace(key, p2, p3, p4, p5) {
		if (p5 === undefined) {
			this.client.multi()
				.del(key)
				.set(p2, this.normalize(p3))
				.exec((err, replies) => {
					db.log.info('MULTI got %d replies', replies.length);
					replies.forEach((reply, index) => {
						db.log.info("Reply %d: %s", index, reply);
					});
				});
		} else {
			// hash
			this.client.multi()
				.hdel(key, p2)
				.hset(key, p3, this.normalize(p4))
				.exec((err, replies) => {
					db.log.info('MULTI got %d replies', replies.length);
					replies.forEach((reply, index) => {
						db.log.info("Reply %d: %s", index, reply);
					});
				});
		}
	};

	/**
	 * @param {Number|Boolean} value
	 * @returns {Boolean}
	 */
	isTrue(value) { return value == 1; }

	/**
	 * @param {String|Boolean} value
	 * @returns {Boolean}
	 */
	isOkay(value) { return value == 'OK'; }

	/**
	 * Normalize data value for cache storage
	 * @param {Object|String|Array} value
	 * @return {String}
	 */
	normalize(value) {
		if (typeof value == 'object') {
			return (value instanceof CacheItem) ? value.serialize() : JSON.stringify(value);
		} else {
			return value;
		}
	}

	/**
	 * Deserialize objects as needed
	 * @param {Object|String} value
	 * @return {Object|CacheItem}
	 */
	parseObject(value) {
		if (is.empty(value)) {
			return null;
		} else {
			value = JSON.parse(value);

			if (CacheItem.isType(value)) {
				return CacheItem.deserialize(value);
			} else {
				return value;
			}
		}
	}

	/**
	 * Disconnect from Redis
	 */
	disconnect() { this.client.end(); }
}

module.exports = RedisCache;

// - Private static members ---------------------------------------------------

const code = {
	BROKEN: 'CONNECTION_BROKEN',
	TIMEOUT: 'ETIMEDOUT',
	ERROR: 'ERR'
};
