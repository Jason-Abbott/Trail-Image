'use strict';

const TI = require('../');
const Cache = TI.Provider.Cache;
const is = TI.is;
const events = require('events');

/**
 * Cache provider base class
 * @extends EventEmitter
 * @alias TI.Provider.Cache.Base
 */
class CacheBase extends events.EventEmitter {
	constructor() {
		super();

		/**
		 * Whether cache provider still needs to be authorized (i.e. OAuth)
		 * @type Boolean
		 */
		this.needsAuth = false;

		/**
		 * Whether provier is ready to receive commands
		 * Redis and others can receive commands before they're connected
		 * @type Boolean
		 */
		this.ready = true;
		/**
		 * Whether the provider is connected
		 * @type Boolean
		 */
		this.connected = false;
	}

	select(key, callback) {}

	selectMember(key, memberKey, callback) {}

	selectAll(key, callback) {}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} value
	 * @param {function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	add(key, value, callback) {}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {String} value
	 * @param {function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	addMember(key, memberKey, value, callback) {}

	/**
	 * Insert hash
	 * @param {String} key
	 * @param {Object} hash
	 * @param {Function} callback
	 */
	addAll(key, hash, callback) {}

	exists(key, callback) {}

	memberExists(key, memberKey, callback) {}

	/**
	 * All keys matching pattern
	 * @param {String} pattern
	 * @param {function(Number, [String[]])} callback
	 */
	keys(pattern, callback) {}

	/**
	 * Fields contained in key
	 * @param {String} key
	 * @param callback
	 */
	memberKeys(key, callback) {}

	/**
	 * @param {String|String[]} key One or more item keys
	 * @param {function} callback
	 */
	remove(key, callback) {}

	removeMember(key, memberKey, callback) {}

	/**
	 * Normalize response from a particular
	 * @param {String} key Cache key
	 * @param {Function} callback Method that receives value
	 * @param {Number} type Date type
	 * @returns {Function Method that handles the provider-specific response}
	 */
	responder(key, callback, type) {
		return (err, reply) => {
			let error = this.hasError(key, err);

			if (is.callable(callback)) {
				let response = null;
				if (type === undefined) { type = Cache.DataType.NONE; }

				if (error) {
					if (type !== Cache.DataType.RAW && type !== Cache.DataType.JSON) { response = false; }
				} else {
					switch (type) {
						case Cache.DataType.BIT: response = this.isTrue(reply); break;
						case Cache.DataType.OKAY: response = this.isOkay(reply); break;
						case Cache.DataType.COUNT: response = (reply == howMany(key)); break;
						case Cache.DataType.RAW: response = reply; break;
						case Cache.DataType.JSON: response = this.parseObject(reply); break;
						case Cache.DataType.NONE: response = true; break;
					}
				}
				callback(response);
			}
		}
	}

	/**
	 * Override to deserialize
	 * @param {Object|String} value
	 * @returns {Object|CacheItem}
	 */
	parseObject(value) { return (is.value(value)) ? value : null; }

	/**
	 * Override for serializations
	 * @param {Number|Boolean} value
	 * @returns {Boolean}
	 */
	isTrue(value) { return value; }

	/**
	 * Override for serializations
	 * @param {String|Boolean} value
	 * @returns {Boolean}
	 */
	isOkay(value) { return value; }

	/**
	 * Whether Redis returned an error
	 * @param {String|String[]} key
	 * @param {Object|Number|String} err
	 * @returns {Boolean}
	 */
	hasError(key, err) {
		if (err !== null) {
			if (is.array(key)) { key = key.toString(); }
			TI.log.error('Operation with key "%s" resulted in %s', key, err.toString());
			return true;
		}
		return false;
	}

	/**
	 * Override if provider needs serialization
	 * @param {Object|String|Array} value
	 */
	normalize(value) { return value; }
}

module.exports = CacheBase;

// - Private static members ---------------------------------------------------

/**
 * How many datum referenced by key
 * @param {String|String[]} key
 * @returns {Number}
 */
function howMany(key) { return is.array(key) ? key.length : 1; }