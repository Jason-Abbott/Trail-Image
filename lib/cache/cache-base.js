'use strict';

const is = require('../is.js');
const events = require('events');

/**
 * Cache provider base class
 * @extends {EventEmitter}
 */
class CacheBase extends events.EventEmitter {
	constructor() {
		super();

		// avoid circular reference
		log = require('../config.js').provider.log;

		/**
		 * Whether provier is ready to receive commands
		 * Redis and others can receive commands before they're connected
		 * @type {Boolean}
		 */
		this.ready = true;
		/**
		 * Whether the provider is connected
		 * @type {Boolean}
		 */
		this.connected = false;
	}

	/**
	 * Expected hash response used for validation and parsing
	 * @return {Object.<Number>}
	 */
	static get dataType() {
		return {
			NONE: 0,            // don't check the reply
			OKAY: 1,            // check for 'OK'
			COUNT: 2,           // reply should match key count
			BIT: 3,             // 1 or 0
			RAW: 4,             // return raw data without validation or parsing
			JSON: 5             // parse as JSON
		};
	}

	/**
	 * @returns {Object.<String>}
	 */
	static get eventType() {
		return {
			CONNECTED: 'connected',
			FATAL: 'fatal'
		};
	}

	select(key, callback) {}

	selectMember(key, memberKey, callback) {}

	selectAll(key, callback) {}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} value
	 * @param {function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	add(key, value, callback) {}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {String} value
	 * @param {function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	addMember(key, memberKey, value, callback) {}

	/**
	 * Insert hash
	 * @param {String} key
	 * @param {Object} hash
	 * @param {Function} callback
	 */
	addAll(key, hash, callback) {}

	exists(key, callback) {}

	memberExists(key, memberKey, callback) {}

	keys(key, callback) {}

	memberKeys(key, callback) {}

	/**
	 * @param {String|String[]} key One or more item keys
	 * @param {function} callback
	 */
	remove(key, callback) {}

	removeMember(key, memberKey, callback) {}

	/**
	 *
	 * @param {String} key
	 * @param {Function} callback
	 * @param {Number} type
	 * @returns {Function}
	 */
	responder(key, callback, type) {
		return (err, reply) => {
			let error = this.hasError(key, err);

			if (is.callable(callback)) {
				let response = null;
				if (type === undefined) { type = CacheBase.dataType.NONE; }

				if (error) {
					if (type !== CacheBase.dataType.RAW && type !== CacheBase.dataType.JSON) { response = false; }
				} else {
					switch (type) {
						case CacheBase.dataType.BIT: response = this.isTrue(reply); break;
						case CacheBase.dataType.OKAY: response = this.isOkay(reply); break;
						case CacheBase.dataType.COUNT: response = (reply == howMany(key)); break;
						case CacheBase.dataType.RAW: response = reply; break;
						case CacheBase.dataType.JSON: response = this.parseObject(reply); break;
						case CacheBase.dataType.NONE: response = true; break;
					}
				}
				callback(response);
			}
		}
	}

	/**
	 * Deserialize object strings
	 * @param {Object|String} value
	 */
	parseObject(value) {
		return (is.empty(value)) ? null : JSON.parse(value);
	}

	/**
	 * @param {Number|Boolean} value
	 * @returns {Boolean}
	 */
	isTrue(value) { return value == 1; }

	/**
	 * @param {String|Boolean} value
	 * @returns {Boolean}
	 */
	isOkay(value) { return value == 'OK'; }

	/**
	 * Whether Redis returned an error
	 * @param {String|String[]} key
	 * @param {Object|Number|String} err
	 * @return {Boolean}
	 */
	hasError(key, err) {
		if (err !== null) {
			if (is.array(key)) { key = key.toString(); }
			log.error('Operation with key "%s" resulted in %s', key, err.toString());
			return true;
		}
		return false;
	}

	/**
	 * Normalize data value
	 * @param {Object|String|Array} value
	 */
	normalize(value) { return (typeof value == 'object') ? JSON.stringify(value) : value; }
}

module.exports = CacheBase;

// - Private static members ---------------------------------------------------

/**
 * @type {LogBase}
 */
let log = null;

/**
 * How many datum referenced by key
 * @param {String|String[]} key
 * @returns {Number}
 */
function howMany(key) { return is.array(key) ? key.length : 1; }