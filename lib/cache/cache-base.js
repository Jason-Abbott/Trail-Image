'use strict';

const is = require('../is.js');
const events = require('events');
const db = require('../config.js').provider;

/**
 * Cache provider base class
 * @extends {EventEmitter}
 */
class CacheBase extends events.EventEmitter {
	constructor() {
		super();

		/**
		 * Whether cache provider still needs to be authorized (i.e. OAuth)
		 * @type {boolean}
		 */
		this.needsAuth = false;

		/**
		 * Whether provier is ready to receive commands
		 * Redis and others can receive commands before they're connected
		 * @type {Boolean}
		 */
		this.ready = true;
		/**
		 * Whether the provider is connected
		 * @type {Boolean}
		 */
		this.connected = false;
	}

	select(key, callback) {}

	selectMember(key, memberKey, callback) {}

	selectAll(key, callback) {}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} value
	 * @param {function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	add(key, value, callback) {}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {String} value
	 * @param {function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	addMember(key, memberKey, value, callback) {}

	/**
	 * Insert hash
	 * @param {String} key
	 * @param {Object} hash
	 * @param {Function} callback
	 */
	addAll(key, hash, callback) {}

	exists(key, callback) {}

	memberExists(key, memberKey, callback) {}

	/**
	 * All keys matching pattern
	 * @param {String} pattern
	 * @param {function(Number, [String[]])} callback
	 */
	keys(pattern, callback) {}

	/**
	 * Fields contained in key
	 * @param {String} key
	 * @param callback
	 */
	memberKeys(key, callback) {}

	/**
	 * @param {String|String[]} key One or more item keys
	 * @param {function} callback
	 */
	remove(key, callback) {}

	removeMember(key, memberKey, callback) {}

	/**
	 *
	 * @param {String} key
	 * @param {Function} callback
	 * @param {Number} type
	 * @returns {Function}
	 */
	responder(key, callback, type) {
		return (err, reply) => {
			let error = this.hasError(key, err);

			if (is.callable(callback)) {
				let response = null;
				if (type === undefined) { type = CacheBase.DataType.NONE; }

				if (error) {
					if (type !== CacheBase.DataType.RAW && type !== CacheBase.DataType.JSON) { response = false; }
				} else {
					switch (type) {
						case CacheBase.DataType.BIT: response = this.isTrue(reply); break;
						case CacheBase.DataType.OKAY: response = this.isOkay(reply); break;
						case CacheBase.DataType.COUNT: response = (reply == howMany(key)); break;
						case CacheBase.DataType.RAW: response = reply; break;
						case CacheBase.DataType.JSON: response = this.parseObject(reply); break;
						case CacheBase.DataType.NONE: response = true; break;
					}
				}
				callback(response);
			}
		}
	}

	/**
	 * Override to deserialize
	 * @param {Object|String} value
	 * @return {Object|CacheItem}
	 */
	parseObject(value) { return (is.value(value)) ? value : null; }

	/**
	 * Override for serializations
	 * @param {Number|Boolean} value
	 * @returns {Boolean}
	 */
	isTrue(value) { return value; }

	/**
	 * Override for serializations
	 * @param {String|Boolean} value
	 * @returns {Boolean}
	 */
	isOkay(value) { return value; }

	/**
	 * Whether Redis returned an error
	 * @param {String|String[]} key
	 * @param {Object|Number|String} err
	 * @return {Boolean}
	 */
	hasError(key, err) {
		if (err !== null) {
			if (is.array(key)) { key = key.toString(); }
			db.log.error('Operation with key "%s" resulted in %s', key, err.toString());
			return true;
		}
		return false;
	}

	/**
	 * Override if provider needs serialization
	 * @param {Object|String|Array} value
	 */
	normalize(value) { return value; }
}

/**
 * Expected hash response used for validation and parsing
 * @return {Object.<Number>}
 */
CacheBase.DataType = {
	NONE: 0,            // don't check the reply
	OKAY: 1,            // check for 'OK'
	COUNT: 2,           // reply should match key count
	BIT: 3,             // 1 or 0
	RAW: 4,             // return raw data without validation or parsing
	JSON: 5             // parse as JSON
};

/**
 * @returns {Object.<String>}
 */
CacheBase.EventType = {
	CONNECTED: 'connected',
	FATAL: 'fatal'
};

module.exports = CacheBase;

// - Private static members ---------------------------------------------------

/**
 * How many datum referenced by key
 * @param {String|String[]} key
 * @returns {Number}
 */
function howMany(key) { return is.array(key) ? key.length : 1; }