'use strict';

const TI = require('../');
const CacheBase = TI.Provider.Cache.Base;
const is = TI.is;
const cache = {};

/**
 * Hash kept in memory
 * Match Redis behavior
 * @extends {EventEmitter}
 * @extends {TI.Provider.Cache.Base}
 * @namesapce TI.Provider.Cache.Memory
 */
class MemoryCache extends CacheBase {
	constructor() {
		super();
		this.connected = true;
	}

	select(key, callback) {
		if (contains(key)) {
			callback(MemoryCache.ErrorType.None, cache[key]);
		} else {
			callback(MemoryCache.ErrorType.NotFound);
		}
	}

	selectMember(key, memberKey, callback) {
		if (contains(key, memberKey)) {
			callback(MemoryCache.ErrorType.None, cache[key][memberKey]);
		} else {
			callback(MemoryCache.ErrorType.NotFound);
		}
	}

	selectAll(key, callback) {
		// returning a field that's a hash is no different than returning a primitive type
		this.select(key, callback);
	}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} value
	 * @param {function(Object, (String|Number)} [callback] Method generated by responder()
	 */
	add(key, value, callback) {
		cache[key] = value;
		if (is.callable(callback)) { callback(MemoryCache.ErrorType.None, true); }
	}

	/**
	 * Insert value into hash
	 * @param {String} key
	 * @param {String} memberKey
	 * @param {String} value
	 * @param {function(Object, (String|Number)} [callback] Method generated by responder()
	 * @see http://redis.io/commands/hset
	 */
	addMember(key, memberKey, value, callback) {
		// match redis behavior
		let created = true;

		if (contains(key)) {
			created = false;
		} else {
			cache[key] = {};
		}
		cache[key][memberKey] = value;

		callback(MemoryCache.ErrorType.None, created);
	}

	addAll(key, hash, callback) {
		cache[key] = hash;
		if (is.callable(callback)) { callback(MemoryCache.ErrorType.None, true); }
	}

	exists(key, callback) {
		callback(MemoryCache.ErrorType.None, contains(key));
	}

	memberExists(key, memberKey, callback) {
		callback(MemoryCache.ErrorType.None, contains(key, memberKey));
	}

	/**
	 * Keys matching pattern
	 * @param {String} pattern
	 * @param {function(Number, [String[]])} callback
	 */
	keys(pattern, callback) {
		let re = ruleToPattern(pattern);
		let keys = Object.keys(cache).filter(k => re.test(k));
		let error = (keys.length > 0) ? MemoryCache.ErrorType.None : MemoryCache.ErrorType.NotFound;

		callback(error, keys);
	}

	memberKeys(key, callback) {
		let fields = [];
		let error = MemoryCache.ErrorType.NotFound;

		if (is.defined(cache, key)) {
			fields = Object.keys(cache[key]);
			if (fields.length > 0) { error = MemoryCache.ErrorType.None; }
		}
		callback(error, fields);
	}

	/**
	 * @param {String|String[]} key One or more item keys
	 * @param {function} callback
	 */
	remove(key, callback) {
		let removed = 0;

		if (is.array(key)) {
			for (let k of key) {
				if (contains(k)) {
					removed++;
					delete cache[k];
				}
			}
		} else if (contains(key)) {
			removed = 1;
			delete cache[key];
		}
		callback(MemoryCache.ErrorType.None, removed);
	}

	removeMember(key, memberKey, callback) {
		let removed = 0;

		if (contains(key, memberKey)) {
			removed = 1;
			delete cache[key][memberKey];
		}
		callback(MemoryCache.ErrorType.None, removed);
	}

	/**
	 * Whether cache access caused an error
	 * @param {String|String[]} key
	 * @param {Object|Number|String} err
	 * @return {Boolean}
	 */
	hasError(key, err) {
		if (is.value(err) && err != MemoryCache.ErrorType.None) {
			if (is.array(key)) { key = key.toString(); }
			let message = 'an unknown error';

			switch (err) {
				case MemoryCache.ErrorType.NotFound: message = 'key not found'; break;
			}
			TI.log.error('Cache operation with key "%s" resulted in %s', key, message);
			return true;
		}
		return false;
	}
}

MemoryCache.ErrorType = {
	None: 0,
	NotFound: 1
};

module.exports = MemoryCache;

// - Private static members ---------------------------------------------------

/**
 * Whether key and memberKey are in the memory hash
 * @param {String} key
 * @param {String} [memberKey]
 * @returns {Boolean}
 */
function contains(key, memberKey) {
	let defined = is.defined(cache, key);

	return (defined && memberKey !== undefined)
		? is.defined(cache[key], memberKey)
		: defined;
}

/**
 * Convert wildcards to regex pattern
 * @param {String} rule
 * @return {RegExp}
 */
function ruleToPattern(rule) {
	rule = rule.replace('*', '.*');
	rule = rule.replace('?', '.?');
	rule = '^' + rule + '$';
	return new RegExp(rule);
}