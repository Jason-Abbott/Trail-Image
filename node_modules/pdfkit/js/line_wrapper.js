(function() {
  var EventEmitter, LineBreaker, LineWrapper;
  var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  LineBreaker = require('linebreak');

  LineWrapper = (function() {

    __extends(LineWrapper, EventEmitter);

    function LineWrapper(document) {
      var _this = this;
      this.document = document;
      this.on('firstLine', function(options) {
        var indent;
        indent = options.indent || 0;
        _this.document.x += indent;
        _this.lineWidth -= indent;
        return _this.once('line', function() {
          _this.document.x -= indent;
          return _this.lineWidth += indent;
        });
      });
      this.on('lastLine', function(options) {
        var align;
        align = options.align;
        if (align === 'justify') options.align = 'left';
        _this.lastLine = true;
        return _this.once('line', function() {
          _this.document.y += options.paragraphGap || 0;
          options.align = align;
          return _this.lastLine = false;
        });
      });
    }

    LineWrapper.prototype.wrap = function(text, options) {
      var bk, breaker, buffer, charSpacing, emitLine, indent, last, lineWidth, nextY, spaceLeft, textWidth, w, wc, width, word, wordSpacing, wordWidths, _ref, _ref2;
      var _this = this;
      width = this.document.widthOfString.bind(this.document);
      indent = options.indent || 0;
      charSpacing = options.characterSpacing || 0;
      wordSpacing = options.wordSpacing === 0;
      this.columns = options.columns || 1;
      this.columnGap = (_ref = options.columnGap) != null ? _ref : 18;
      this.lineWidth = (options.width - (this.columnGap * (this.columns - 1))) / this.columns;
      this.startY = this.document.y;
      this.column = 1;
      this.maxY = this.startY + options.height;
      nextY = this.document.y + this.document.currentLineHeight(true);
      if (this.document.y > this.maxY || nextY > this.maxY) this.nextSection();
      wordWidths = {};
      this.emit('sectionStart', options, this);
      breaker = new LineBreaker(text);
      last = null;
      buffer = '';
      textWidth = 0;
      wc = 0;
      emitLine = function() {
        options.textWidth = textWidth + wordSpacing * (wc - 1);
        options.wordCount = wc;
        options.lineWidth = _this.lineWidth;
        return _this.emit('line', buffer, options, _this);
      };
      spaceLeft = this.lineWidth - indent;
      while (bk = breaker.nextBreak()) {
        if (!(last != null) || last.required) {
          this.emit('firstLine', options, this);
        }
        word = text.slice((last != null ? last.position : void 0) || 0, bk.position);
        w = (_ref2 = wordWidths[word]) != null ? _ref2 : wordWidths[word] = width(word, options) + charSpacing + wordSpacing;
        if (w <= spaceLeft) {
          buffer += word;
          lineWidth += w;
          wc++;
        }
        if (bk.required || w > spaceLeft) {
          if (bk.required) this.emit('lastLine', options, this);
          emitLine();
          if (this.document.y > this.maxY) this.nextSection();
          if (bk.required) {
            spaceLeft = this.lineWidth - indent;
            buffer = '';
            lineWidth = 0;
            wc = 0;
          } else {
            spaceLeft = this.lineWidth - w;
            buffer = word;
            lineWidth = w;
            wc = 1;
          }
        } else {
          spaceLeft -= w;
        }
        last = bk;
      }
      if (wc > 0) {
        this.emit('lastLine', options, this);
        emitLine();
      }
      return this.emit('sectionEnd', options, this);
    };

    LineWrapper.prototype.nextSection = function(options) {
      var x;
      this.emit('sectionEnd', options, this);
      if (++this.column > this.columns) {
        x = this.document.x;
        this.document.addPage();
        this.column = 1;
        this.startY = this.document.page.margins.top;
        this.maxY = this.document.page.maxY();
        this.document.x = x;
        this.emit('pageBreak', options, this);
      } else {
        this.document.x += this.lineWidth + this.columnGap;
        this.document.y = this.startY;
        this.emit('columnBreak', options, this);
      }
      return this.emit('sectionStart', options, this);
    };

    return LineWrapper;

  })();

  module.exports = LineWrapper;

}).call(this);
